# 트리(tree) 📚

```
트리란? 🌴

우리는 이런 구조를 일반적으로 트리 구조라고 합니다. 나무 같지 않는가? 나무를 180도 돌려서 보면 맨 위에는 큰 하나의 기둥이 있고, 아래로 내려갈수록 가지가 계속 뻗어나오는 것을 볼 수 있다.
그렇기 때문에 우리는 이 구조를 트리 구조라고 부르는 것이다. 트리는 두 지점의 연결 관계로 구성되어 있는데, 계층관계가 존재한다는 것이 특징이 있다.
우리는 하나의 연결 관계에서 위쪽에 있는 점을 '부모' 라고 부르며, 아래쪽에 있는 점을 '자식' 이라고 부를 것 입니다.
이 외에도 추가적인 용어들을 살펴보자.
```






<img src = "https://s3-ap-northeast-2.amazonaws.com/codetreepublic/problems/574/images/1222106e-f600-4a68-b42e-94bf3852d318.png">


```
트리 용어 정리 ⭐️

노드: 각 지점을 의미합니다. 정점이라 부르기도 한다.
간선: 두 노드를 연결하는 선을 의미합니다. 에지라고 부르기도 한다.
루트 노드: 트리에서 맨 꼭데기 노드를 의미한다.
부모, 자식: 트리에서 연결된 두 노드의 관계를 의미하는데, 더 위쪽에 있는 노드를 부모 노드, 아래쪽에 있는 노드를 자식 노드라고 부른다.
차수: 특정 노드를 기준으로, 자식의 수가 얼마나 되는지 의미한다.
깊이: 루트 노드와 얼마나 떨어져 있는지를 가리키는 말이다.
높이: 트리에서 깊이가 가장 깊은 노드의 깊이 혹은 1을 더한 값을 의미합니다. 코드트리에서는 앞으로 트리의 높이를 최대 깊이에 1을 더한 값으로 생각하도록 하자.
리프 노드: 자식을 갖고 있지 않은 노드를 의미한다.
```
![Alt 트리](https://s3-ap-northeast-2.amazonaws.com/codetreepublic/problems/574/images/6960f8d2-6881-46ed-8543-6961a3d57fd1.png)

> Rooted Tree 와 Unrooted Tree의 차이

```
놀랍게도 밑에 있는 이미지와 같이 부모 자식 관계가 정의되지 않는 경우에도 트리라고 부릅니다. 
즉, 트리의 원래 정의는 노드끼리 전부 연결되어 있으면서 사이클이 존재하지 않는 그래프이다. 이런 경우를 'Unrooted tree'라고 부른다.
위에서 살펴본 이미지 경우에서 처럼 루트 노드가 설정되어있는 트리는 'Rooted tree'라고 부릅니다. 참고로 Unrooted tree에서의 차수는 노드에 연결된 간선의 개수이고, 
리프 노드의 정의는 차수가 1인 노드가 된다. Unrooted tree 에서 루트 노드는 사용자가 정의하기 나름이다.
```

![Alt unrooted tree](https://s3-ap-northeast-2.amazonaws.com/codetreepublic/problems/574/images/7c703592-7794-4fe7-a32c-9e25f73c8de7.png)

## 이진 트리(Binary tree) 🌴

```
이진 트리란?

트리 구조중 자식의 수가 최대 2개인 트리의 한 종류이다.
이진트리의 자식은 두개이기 때문에, 하나는 왼쪽에, 그리고 다른 하나는 오른쪽에 존재한다고 볼 수 있을 있다. 우리는 왼쪽/오른쪽 자식이라고 구분하도록 하겠다.
배열의 0번 값을 비우고, 루트 노드를 1번에 넣어주도록 하자. 그리고 왼쪽 자식을 2번에, 오른쪽 자식을 3번에 넣어준다. 그 후 왼쪽 자식과 오른쪽 자식을 알맞게 넣어주면 된다.
이렇게 넣게 되면, 특정 노드의 위치가 i라고 한다면, 자연스럽게 왼쪽 자식의 위치는 i * 2, 오른쪽 자식의 위치는 i * 2 + 1이 되는걸 볼 수 있다. 
즉, 이진트리는 배열로 구현이 가능하며 특정 노드 i의 자식 노드를 조회하기 위해서는 i * 2, i * 2 + 1을 하면 된다.
반대로 부모노드의 위치는 i / 2로 결정된다는 것을 어렵지 않게 알 수 있다.
자식의 수가 제한되어 있어서, 구현하기 상대적으로 간편하다는 장점이 있다. 특히, 배열을 사용하면 부모에서 자식으로 이동하는 연산 또한 구현할 수 있기에 다양한 알고리즘에 사용된다.

```

![binary tree](https://s3-ap-northeast-2.amazonaws.com/codetreepublic/problems/576/images/2f2527dd-b0d0-42e3-b193-720a344cb8b4.png)

```
이진 트리의 탐색 기법


이진트리는 재귀를 사용하면 탐색을 비교적 쉽게 구현할 수 있다.
어떤식으로 방문하는 순서에 따라 크게 세가지로 나뉜다.
각각 전위 탐색 (Preorder Traversal), 중위 탐색 (Inorder Traversal), 후위 탐색 (Postorder Traversal) 이다.
밑에 그림을 보고 각 탐색 기법을 구체적으로 배워보자!
```

![Search](https://mblogthumb-phinf.pstatic.net/20120331_173/rlakk11_1333202999001hceVs_JPEG/4.jpg?type=w2)

```
1. 전위 탐색
전위 탐색은 부모 - 왼쪽 자식 - 오른쪽 자식순으로 탐색한다. 이 뜻은 모든 노드에 대해 부모에 먼저 색칠을 진행한 후,
왼쪽 자식들을 전부 순회하고, 그 이후에 오른쪽 자식들을 방문함을 뜻한다.
따라서 위에 이진 트리에서의 전위 탐색의 순서는 : 0->1->3->7->8->4->9->10->2->5->11->6 이 된다.

2. 중위 탐색
중위 탐색은 왼쪽 자식 - 부모 - 오른쪽 자식순으로 탐색한다. 이 뜻은 모든 노드에 대해 왼쪽 자식들을 먼저 전부 순회한 후,
부모에 색칠을 진행하고 그 이후에 오른쪽 자식들을 방문함을 뜻한다.
따라서 위에 이진 트리에서의 중위 탐색의 순서는 : 7->3->8->1->9->4->10->0->11->5->2->6 이 된다.

3. 후위 탐색
후위 탐색은 왼쪽 자식 - 오른쪽 자식 - 부모순으로 탐색한다. 이 뜻은 모든 노드에 대해 왼쪽 자식들을 먼저 전부 순회한 후,
오른쪽 자식들을 전부 순회하고 그 이후에 마지막으로 부모에 색칠을 진행함을 뜻한다.
따라서 위에 이진 트리에서의 후위 탐색의 순서는 : 7->8->3->9->10->4->1->11->5->6->2->0 이 된다.


- 각 탐색 기법의 수도 코드(재귀) 🔥

function preorder(n)
  if n == null
    return
  visit(n)
  preorder(n.left)
  preorder(n.right)

function inorder(n)
  if n == null
    return
  inorder(n.left)
  visit(n)
  inorder(n.right)
  
function postorder(n)
  if n == null
    return
  postorder(n.left)
  postorder(n.right)
  visit(n)
  
// visit(n) -> n 노드를 방문 기록
```
