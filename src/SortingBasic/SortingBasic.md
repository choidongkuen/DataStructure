## 정렬(sorting) 📚

```
정렬 알고리즘

배열에 데이터를 담게 되면, 가끔은 데이터를 정렬하고 싶을 때가 있을 것다. 
당연히 정렬된 데이터가 그렇지 않은 데이터에 비해 보기도 편하고, 상황에 따라 다루기도 편하기 때문이다.
이처럼 정렬의 중요성은 높기 때문에, 수많은 정렬 알고리즘이 연구되었다.
우리는 일상적인 정렬 알고리즘에서 시작하여, 개선된 시간의 정렬 알고리즘까지 공부할 것이다.

- 대표적인 정렬 방법

1. 버블 정렬
2. 선택 정렬
3. 삽입 정렬    
4. 기수 정렬 
5. 병합 정렬    
6. 퀵 정렬
7. 힙 정렬
```
> 기본적인 정렬 방식 4가지를 알아보자.🤓
### 1. 버블 정렬(Bubble sort)
```
- 버블 정렬이란?

버블 정렬은 가장 단순한 정렬 알고리즘이다.
기본적인 아이디어는 간단하다. 첫번째와 두번째 값을 비교하고, 두번째와 세번째 값을 비교하고, ... n-1번째와 n번째 값을 비교한다. 
이 과정에서 순서가 맞지 않은 값을 서로 교환해준다. 이런 절차를 정렬이 될 때 까지 반복한다.
코드를 작성하는 것은 어렵지 않지만, 상당히 비효율적인 알고리즘이기 때문에, 성능이 다른 알고리즘에 비해 좋지 않다는 단점이 있다.



- 버블 정렬의 시간복잡도 🕙

교환 여부를 확인하기 위해 전체 값을 한 바퀴 도는데, 이 시간복잡도는 자연스럽게 O(N)이 될 것 이다.
그렇다면 거품 정렬의 시간복잡도는 "최악의 경우 몇 바퀴나 배열을 순회할까?" 라는 질문의 대답에 따라 결정되지 않겠는가?
이런것을 추론하는데 익숙하지 않을 수 있으니, 간단한 예시를 통해 알아보자.

>> 5 4 3 2 1

이런 식으로 역순으로 데이터가 존재한다고 가정해보자.
한 바퀴를 돌게 되면, 4 3 2 1 5라는 데이터가 된다.
두 바퀴를 돌게 되면, 3 2 1 4 5라는 데이터가 된다.
자세히 살펴보면, 한 바퀴 돌 때 마다 데이터 한 개씩 제자리로 가게 된다.
즉, N - 1 바퀴 돌아야 한다는 이야기이다. (N - 1)개가 제자리로 가게 된다면, 나머지 한 개는 당연히 남은 자리로 가게 될테니 N번을 돌지 않아도 된다..
따라서, O(N^2)이라는 시간복잡도를 보여주게 된다.


- 버블 정렬의 수도 코드 🔥️

function bubble_sort(arr[])
  set len = arr.size
  
  for i = 0 ... i < len - 1
    for j = 0 ... j < len - 1 - i
      if arr[j] > arr[j + 1]
        set tmp = arr[j]
        arr[j] = arr[j + 1]
        arr[j + 1] = tmp
  
  return arr
```
### 2. 선택 정렬(Selection sort)
```
- 선택 정렬이란?

다른 정렬 알고리즘보다 더 일상적인 방법의 알고리즘이라 할 수 있는 것이 바로 선택 정렬이다.
주 아이디어는 다음과 같다.

1. 전체 값 중 가장 작은 값을 찾음
2. 해당 값을 맨 첫번째에 배치함.
3. 첫번째 값을 제외하고 가장 작은 값을 찾아 두번째에 배치함.
4. 두번째, 세번째, ... n-1번째 값을 제외하고 가장 작은 값을 찾아 정해진 위치에 배치함.


- 선택 정렬의 시간복잡도 🕙

중간에 정렬된 상태라면 종료될 수 있는 거품 정렬과는 다르게, 
선택 정렬의 경우 반드시 n−1,n−2,...2,1번의 비교 연산을 수행해야 하기 때문에 
약 n∗(n−1)/2 번의 연산을 필요로 한다. 따라서, 자연스럽게 시간복잡도는 O(N^2)이 될 것 이다.


- 선택 정렬의 수도 코드 🔥️

function selection_sort(arr[])
  set len = arr.size
  for i = 0 ... i < len-1
    set min = i
    for j = i+1 ... j < len
      if arr[j] < arr[min]
        min = j
    set tmp = arr[i]
    arr[i] = arr[min]
    arr[min] = tmp
  
  return arr
```
### 3. 삽입 정렬(Insertion sort)
```
- 삽입 정렬이란?

삽입정렬은, 앞에서부터 순서대로 보면서 앞에 있는 모든 원소가 
정렬이 되어 있다는 가정 하에서 현재 원소의 위치를 적절하게 집어넣는 정렬이다.
```

<img src = "https://t1.daumcdn.net/cfile/tistory/2569FD3854508BE811">

```
- 선택 정렬의 시간복잡도 🕙

n개의 원소에 대해 값 삽입을 수행해야 하는데, 
2번째 원소의 경우엔 최대 1개의 원소를 이동해야 하고, 3번째 원소의 경우엔 최대 2개의 원소를 이동해야 하며, 
n번째 원소까지 삽입하는 경우엔 최대 n−1개의 원소가 이동해야 하므로 결과적으로 
최대 n(n−1)/2 개의 원소가 이동해야 하기 때문에, O(N^2)의 시간복잡도가 나올 것이라고 판단할 수 있다.


- 선택 정렬의 수도 코드 🔥️

function insertion_sort(arr[])
  set size = arr.size
  for i = 1 ... i < size
    set j = i - 1 
    set key = arr[i]
    while j >= 0 && arr[j] > key
      a[j + 1] = a[j]
      j--
    a[j + 1] = key
  return arr
```
### 4. 기수 정렬(Radix sort)

```
- 기수 정렬이란?

앞에서 학습했던 세가지 정렬의 시간복잡도는 전부 O(N^2) 라는 공통점이 있습니다. 
이번에는 조금 특이한 시간복잡도를 가지고 있는 정렬 알고리즘을 설명하도록 하겠습니다.
기수 정렬은 맨 뒤에 있는 자릿수 부터 해당 자릿수를 기준으로 정렬한 뒤, 
점점 앞으로 이동하며 각 자리수를 기준으로 정렬하다가 최종적으로 가장 높은 자리수를 기준으로 정렬하는 방법입니다.

```
<img src = "https://t1.daumcdn.net/cfile/tistory/99792B495A6EDBD631">

```
- 기수 정렬의 시간복잡도 🕙

기수정렬의 시간복잡도는 O(k∗n)으로, 여기서 k는 자릿수를 의미합니다. 
각각의 데이터에 대해 매 자릿수마다 분류작업을 하기 때문에 분류작업이 k번 반복된다고 볼 수 있어 다음과 같은 시간복잡도가 나오는 것입니다.
즉, 비교를 하지 않고 정렬하는 방법이기 때문이다.

- 기수 정렬의 수도 코드 🔥️

function radix_sort(arr, k)
  for pos = k - 1 ... pos >= 0:
    set arr_new = [10][]
    for i = 0 ... i < arr.size
      set digit = posth digit of arr[i]
      arr_new[digit].append(arr[i])

    set store_arr = []
    for i = 0 ... i < 10
      for j = 0 ... j < arr_new[i].size
        store_arr.append(arr_new[i][j])
  
    arr = store_arr

  return arr
```


```
- 지금까지 살펴본 정렬방식들의 정렬속도 비교하기
거품, 선택, 삽입 정렬 알고리즘의 시간복잡도는 O(N^2) 이라는 공통점이 있지만,실제 소요되는 시간이 많이 다르다.
[버블 정렬]의 경우, 일반적으로 셋 중 가장 느리다.
그러나 정렬된 배열의 경우, sorted 의 값이 계속 true이기 때문에 시간이 매우 빨라진다.
[선택 정렬]의 경우 배열의 상태와 상관 없이, 1번째로 작은 원소를 찾고, 2번째로 작은 원소를 찾고, ... 하는 과정을 거치기 때문에 
어떠한 상황이던 동일한 시간을 보여준다.
[삽입 정렬]의 경우 일반적으로는 가장 빠르나, 값이 반대로 정렬되어 있는 경우 성능이 많이 떨어진다는 단점이 있다.
또한, 앞 배열에 값을 삽입하는 알고리즘의 특성상 이미 정렬된 배열에 추가적으로 값을 몇개 추가하여 정렬하는 경우에 좋은 성능을 보여준다.

```

> ### 따라서, 일반적인 경우 삽입 정렬 >= 선택 정렬 >= 버블 정렬
