# 그래프(Graph) 📚

```
그래프란? 🥸

이 순간에도 지구촌 수많은 사람들이 SNS를 통해 활발히 교류중이며, 다양한 네트원크가 구성되어 있다. 밑에 그림은 어느 SNS의 네트워크 관계를 
그림으로 간단히 나타낸 것이다. 이번에 살펴볼 그래프라는 자료구조는 이와 매우 비슷하며, 그래프는 계층이 있지 않으며, 서로 동등한 위치에서 연결된 구조이다.
이전에 배운 '트리'라는 구조는 사실 특수한 그래프 버전이라고 생각하면 되며, 그래프는 트리보다 훨씬 큰 범주를 가지고 있다.

그래프 용어 정리 ⭐️

노드(vertex): 각 지점을 의미한다. 정점이라고 부르기도 한다.
간선(edge): 두 노드를 연결하는 선을 의미한다. 에지라고 부르기도 한다.

-> 그래프는 트리와 달리 부모 - 자식 관계를 갖지 않으며, 헤드 노드와 리프 노드의 개념이 없다. (그래프를 처음 접한다면 그래프와 트리의 각 개념과 차이점부터 익히자 🔥)
```

![](https://velog.velcdn.com/images/choidongkuen/post/b2223d4c-6bae-43c7-abe0-c277c06d848e/image.png)

>그래프의 종류

그래프의 범주는 크기 때문에, 많은 종류가 있다. 카테고리로는 1️⃣ 방향에 따라 방향/무방향,   2️⃣ 순환 유무에 따라 순환/비순환,  3️⃣ 연결 유무에 따라 연결/비연결 그래프로 나눌 수 있다.
또한, 기타 그래프로는 4️⃣ 가중치 그래프  5️⃣ 완전 그래프 등이 있다.


![](https://velog.velcdn.com/images/choidongkuen/post/e9425a46-0403-4d1c-b0c9-4c7c58e7b43a/image.png)


![](https://velog.velcdn.com/images/choidongkuen/post/db807028-90e8-47db-be10-bd8c8c55d581/image.png)



![](https://velog.velcdn.com/images/choidongkuen/post/493b3507-b98b-44cb-b8b3-18387893c1a1/image.png)


## 1) 그래프 구현하기 🤔

그렇다면 주어진 그래프를 어떻게 사용하기 편하게 바꿀 수 있을까?
대표적으로 2가지 방식이 있다. 

>1. 인접행렬(Adjacent Matrix) 🔥

인접 행렬은 ∣V∣×∣V∣ 크기의 2차원 배열을 만들어서 연결 관계를 표현하는 것 이다. 즉, A → B 로 가는 길이 있다면 배열의 값을 1로, 가는 길이 없다면 배열의 값을 0으로 지정하는 것이다.


주요 연산의 시간복잡도와 공간복잡도는 다음과 같다. ⏰

특정 정점 I, J 가 연결되어 있는지를 확인: O(1)
특정 정점과 연결되어 있는 모든 정점을 확인: O(∣V∣)
공간 복잡도: O(∣V∣∗∣V∣)

밑에 제시된 이미지는 인접행렬을 이미지화 한것이다.



![](https://velog.velcdn.com/images/choidongkuen/post/5be70308-c0e2-4440-8b90-4b47bad442d4/image.png)

>2. 인접리스트(Adjacent List) 🔥

 인접 리스트는 인접 리스트는 ∣V∣개의 연결 리스트를 만들고, 연결 리스트에 특정 정점과 인접해있는 정점들의 정보를 담는 식으로 구현할 수 있다.

주요 연산의 시간복잡도와 공간복잡도는 다음과 같다. ⏰

특정 정점 I, J 가 연결되어 있는지를 확인: O(min(degree(I),degree(J)))
특정 정점과 연결되어 있는 모든 정점을 확인:O(degree(X))
공간 복잡도: O(∣V∣+∣E∣)

밑에 제시된 미이지는 인접리스트를 이미지화 한것이다.

![](https://velog.velcdn.com/images/choidongkuen/post/03189d25-86b0-4393-9c04-1bd24f7d86ac/image.png)

> 그렇다면 두 방식에 대한 장단점은 ? 🤔

- ### 인접 행렬  
  - #### _장점_ : 
  1. 앞에서 살펴본바와 같이 인집리스트는 2차원 배열을 이용하기 때문에, 인덱싱에 매우 유리하다. 그렇기 때문에 간선 정보의 확인과 업데이트가 빠름 (시간복잡도 : O(1))
  2. 2차원 배열이라는 친숙한 자료구조를 사용하기 때문에 구현이 상대적으로 까다롭지 않다.
  - #### _단점_ : 
  1. 인접리스트와 달리 큰 메모리 공간을 차지한다.

<br>

- ### 인접 리스트
  - ##### _장점_ : 
  1. 메모리 사용량이 인접행렬에 비해 상대적으로 작다.
  2. 노드의 추가 삭제가 빠름(연결리스트의 원리)
  - ##### _단점_ : 
  1. 간선정보확인이 상대적으로 오래 걸린다.
  2. 연결리스트에 대한 이해가 선행되어야 한다. 상대적으로 구현이 까다롭다.


## 2) 그래프 탐색하기 🥸

 앞에서 그래프 정의와 그래프 구현 방법에 대해서 살펴봤는데, 이렇게 그래프를 우리가 사용하기 좋게
가공 했다면 사용해야하지 않겠는가? 우리는 대부분 그래프를 탐색을 위해 구현한다.(ex 코딩테스트)<br>
📢 그래프 탐색 방법에는 두 가지가 있다. 여기에는 **DFS**와 **BFS**가 있다.

> DFS(Depth First Search)

- **깊이우선탐색**이라고 불리는 **DFS** 방식은 이름에서 유추할 수 있다 싶이, '**최대한 깊게 탐색**' 한 후 더 이상 도달할 수 없는 상태라면 '**재귀적 방식**'으로 다시 이전으로 돌아가는 방식을 말한다.
<br> 밑에 제시된 이미지를 통해 더 자세히 이해해보자.


![](https://velog.velcdn.com/images/choidongkuen/post/04dbe04d-91b5-4a17-b94c-4e9746efcff3/image.png)

```
위에 제시된 이미지는 무방향 그래프이다. 시작 정점을 1로 설정하여, DFS 방식으로 그래프를 탐색할 때(왼쪽 -> 오른쪽) , 방문 순서는 어떻게 될까? 
정답 : 1 - > 2 - > 5 - > 3 - > 6 - > 7 - > 4

DFS를 처리하기 위해 boolean 타입의 visited 1차원 배열을 만들고, 해당 노드를 방문 할 때, 방문 기록을 해준다.
이때, 모든 자식 노드를 확인하는데, 만약 방문한 적이 없는 자식 노드가 있다면, 해당 자식 노드를 매개변수로 하여 다시 DFS 메소드를
재귀적으로 호출해준다.

- DFS 수도 코드 🔥

 function dfs(node):
    visited[node] = true // 방문 기록하기
    
    for child in node : // 모든 인접(자식) 노드 체크
        if(visited[child] == false) : // 해당 자식이 방문한 적이 없다면,
            dfs(child) // 재귀적 호출
     
```

> BFS(Breadth First Search)
- **너비우선탐색**이라고 불리는 **BFS** 방식은 깊이 우선으로 탐색했던 **DFS**와 달리 너비를 우선으로 탐색하는 빙식이다.


