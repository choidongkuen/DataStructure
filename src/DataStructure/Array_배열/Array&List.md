## 배열 (Array) 

```
- 배열이란?
나는 학부 시절부터 다양한 언어를 접하면서, 각 언어마다 배열이라는 자료구조가 있는 것에 매우 감사했다.
왜냐하면 다량의 데이터를 그룹지어, 효율적으로 관리할 수 있기 때문이다. 하지만 효율적인 만큼 사용하는데 있어 
약간의 제약조건이 존재하며 배열에 대한 어느정도에 이해도 요구했다. 
또한 "배열과 리스트의 정확한 차이가 뭐지?"라는 어쩌면 나에게 너무 간지러웠던 질문에 대한 해답을 정리와 함께 풀어가려고 한다.


배열(array)은 같은 타입의 변수들로 이루어진 유한 집합으로 정의된다. 
배열을 구성하는 각각의 값을 배열 요소(element)라고 하며, 배열에서의 위치를 가리키는 숫자는 인덱스(index)라고 한다.
배열은 같은 종류의 데이터를 많이 다뤄야 하는 경우에 사용할 수 있는 가장 기본적인 자료 구조이다.
배열은 선언되는 형식에 따라 1차원 배열, 2차원 배열뿐만 아니라 그 이상의 다차원 배열로도 선언할 수 있다.
하지만 현실적으로 이해하기가 쉬운 2차원 배열을 많이 사용한다.

- 배열의 특징 🤓
1. 고정된 메모리(크기) 를 가진다.
2. (논리) 메모리에 연속적으로 배치되어있다.
3. 순서가 존재한다. -> index
4. Random Access 를 지원한다. -> 인덱스 값을 알면 O(1)에 해당 원소 접근 가능 <임의의 요소에 접근>

- 배열의 장점과 단점
    - 장점 1. 인덱스를 이용해 빠른 접근이 가능
    - 장점 2. 물리적인 메모리상에서도 다 모여있기에, 지역성으로 캐시의 히트율이 높다.
    - 장점 3. 많은 데이터를 효과적으로 관리 가능하다.
    
    - 단점 1. 배열의 크기가 고정되어 있다.
    - 단점 2. 삽입/삭제가 번거롭다.
    - 단점 3. 가변 길이 배열이라고 하더라도 크기가 기존의 크기보다 차이가 많다면 매번 새로운 배열을 생성한다.
```


```
모든 프로그램은 실행(process)되기 위해서 메모리(RAM)에 올라와야 한다. 메모리에 올라가면 프로그램은 프로세스 처리를 
프로세서에 의해 받을 수 있다. 각 프로세스마다 스택,힙,코드 영역,데이터 영역 등으로 나뉘며, 우리가 작성한 소스코드에 존재하는 다양한 변수,메서드,클래스 등이
각각의 자리에 맞게 위치한다. 배열은 일반적으로 데이터 영역에 저장되며 이는 정적영역이다. 따라서, 프로그래머가 미리 사용할 크기를 정해서 소스코드를 작성한다.
메모리에 저장됨으로, 메모리 위치에 맞게 주소가 정해져 있다.
```

![](https://velog.velcdn.com/images/choidongkuen/post/a1327e2b-f0a8-4721-a8e6-87045187d5ab/image.png)

![](https://velog.velcdn.com/images/choidongkuen/post/fd90fa40-e915-4188-99e7-f9c44db391d6/image.png)

```
위에 그림은 배열에 존재하는 원소의 메모리상에서의 위치를 나타낸것이다. 각 원소의 주어진 순서에 맞게 주소가 순서대로 할당된다. 
그렇다면 Random Access를 어떻게 지원할까? 이는 바로 순.차.적 다시말해, 원소가 연.속.적 으로 메모리상에 올라간다는 특징 때문에 가능한것이다.
사용자가 배열에서 a인덱스의 원소에 접근하려고 한다고 가정해보자. 그러면 0번 인덱스부터 차근차근 뒤로 접근하는 것이 아니라, 배열의 시작 메모리 주소에다가 인덱스 X 원소의 크기
를 더한다. 즉 단 한번에 연산을 통해 바로 접근가능한 것이다. 
예를 들어 위에 그림에서 3번째 인덱스를 접근할때, 1000(시작 주소) + 3(인덱스) * 8(각 원소의 크기)를 연산함으로써, 메모리 주소를 바로 구해
접근한다는 것이다.
```

> 검색 대상 요소의 메모리 주소 = 배열의 시작 메모리 주소 + 인덱스 * 원소의 바이트 수


```
- 배열 연산의 시간복잡도 🕖
```


```
위에 이미지는 배열에 특정 값을 삽입하는 과정을 설명하고 있다.
그림에서 보듯이 5라는 원소를 0번 인덱스에 삽입하고 있으며, 이로인해 기존에 있었던 원소들은 한칸 씩 뒤로 밀리게 된다.
따라서 '배열 삽입의 시간복잡도는 O(N)이다'.
```
![](https://velog.velcdn.com/images/choidongkuen/post/bbaac7df-b209-44b6-8585-f42d5260b60e/image.png)

![](https://velog.velcdn.com/images/choidongkuen/post/73553c2b-b206-485b-a8ae-9cc221ec2325/image.png)



```
위에 이미지는 배열의 특정 값을 삭제하는 과정을 설명하고 있다.
3번 인덱스의 원소를 삭제함으로써, 4번 인덱스의 원소부터 앞으로 앞당겨지고 있다. 따라서 최악인 경우(맨 앞 원소를 삭제하는 경우)
모든 원소가 이동해야 함으로 '배열 삭제의 시간복잡도는 O(N)이다'.
```

![](https://velog.velcdn.com/images/choidongkuen/post/fbe4d4e2-0699-4a24-bb05-79ff02b246ac/image.png)

```
위에 이미지는 배열의 특정 값을 탐색하는 과정을 설명하고 있다.
최악의 경우 찾는 원소가 마지막 인덱스에 있을 수 있음으로, '배열 탐색의 시간복잡도는 O(N)이다'. 
```

```
배열 연산 시간 복잡도 정리 🕐 (중요)

    // 배열의 삽입/삭제는 일반적으로 O(N)이다. 하지만 만약 삽입/삭제하려는 위치가 맨 뒤인 경우는 O(1)의 시간 복잡도를 갖는다.

    1. 삽입
        - 맨 앞에 삽입하는 경우 : O(N)
        - 중간에 삽입하는 경우 : O(N)
        - 맨 뒤에 삽입하는 경우 : O(1) (Stack과 유사)
        
    2. 삭제
        - 맨 앞에서 삭제하는 경우 : O(N)
        - 중간에서 삭제하는 경우 : O(N)
        - 맨 뒤에서 삭제하는 경우 : O(1) (Stack과 유사)
        
    3. 탐색
        O(N)
        
    4. k번째 원소 접근
        O(1) (Random Access)
```
## 리스트(List)

```
배열이라는 자료구조가 나를 간지럽혔던 이유는 바로 리스트라는 친구 때문이였다. 나는 처음 언어를 파이썬(Python)으로 시작하였다.
파이썬은 매우 사용하기 편한 언어로써, 배열이라는 자료구조를 리스트를 이용해 표현한다. 배열은 고정된 크기를 가지고 있기에, 코드를 구현하면서
크기에 굉장히 신경써야 한다. 따라서 파이썬에서는 배열과 리스트를 합쳐 리스트로 제공한다. 
이때부턴가 나는 "배열 == 리스트다." 라는 생각이 내 머릿속을 차지했고, 다른언어(C,C++,Java)를 접할때, 배열을 배울때마다, 어딘가 가려웠다(?).


- 리스트란?

리스트는 컴퓨터 과학에서 같은 값이 한 번 이상 존재할 수 있는 일련의 값이 모여있는 추상적 자료형이다. 시퀀스(sequence)라고도 부른다. 
리스트는 배열이 가지고 있는 인덱스라는 장점을 버리고, 빈틈없는 데이터의 적재라는 장점을 취한 자료구조이며, 정적으로 운영되는 배열과 달리 사용자가 처리하는 데이터의
양 만큼 자유롭게 늘어나고 줄어들 수 있다.(정적 배열)

파이썬에서는 리스트로 통합해서 제공하지만, 다른 언어에서는 대부분 배열과 리스트의 구분이 확실하다.
특히 자바는 더욱 그렇다. 따라서 개발자는 더 큰 자유도를 가진다. 또한 리스트에는 배열의 특징이 있는 ArrayList와 연결리스트의 특징이 있는 LinkedList 클래스를 제공한다.

- 리스트의 특징 🤓

1. 크기가 가변적인 메모리(크기)를 가진다.
2. 메모리상에 순서대로 저장되는 것이 아니라, 자유자재로 저장 -> 인덱스로 접근 불가
3. 자바에서는 ArrayList,LinkedList가 있다.

- 리스트의 장점과 단점
    - 장점 1. 데이터 공간을 미리 할당할 필요 없음(동적)
    - 장점 2. 데이터의 추가/삭제에 용이함.
    - 장점 3. 데이터를 효과적으로 관리 가능함.
    
    - 단점 1. 인덱스로 접근 불가하다 -> sequential access 방식
    - 단점 2. 탐색에 불리하다. (random access가 아니므로)
    - 단점 3. 연결 구조를 위한 별도 데이터 공간이 필요
    - 단점 4. 데이터 추가,삭제 시 데이터의 연결을 재구성하는 작업이 필요.
```

![](../../../../../../../var/folders/ks/1d9sd_w5627d7x1x7_xjw9j00000gp/T/TemporaryItems/NSIRD_screencaptureui_7NsQej/스크린샷 2022-08-28 오후 10.39.07.png)



## 연결리스트(LinkedList)

```
연결리스트까지 이해한다면, 리스트에 대한 이해를 완벽하게 할 수 있을것이다. 배열과 리스트에 대한 이해는 컴퓨터 공학자라면 꼭 이해를 하고 넘어가야 하는 부분이다.

- 연결리스트란?

각 노드가 데이터와 포인터를 가지고 한 줄로 연결되어 있는 방식으로 데이터를 저장하는 자료 구조이다. 
이름에서 말하듯이 데이터를 담고 있는 노드들이 연결되어 있는데, 노드의 포인터가 다음이나 이전의 노드와의 연결을 담당하게 된다.
연결 리스트의 종류로는 단일 연결 리스트, 이중 연결 리스트 등이 있다.
자바에서는 LinkedList 컬렉션 프레임워크를 이용하여 구현가능하다.

- 배열의 대항마 연결리스트 🐴

앞으로 연결리스트에 삽입과 삭제를 배우면 이해하겠지만, 연결리스트는 삽입/삭제에 매우 탁월한 성능을 보인다.
삽입/삭제에 일반적으로 O(N) 이 걸리는 배열에 비해 연결리스트는 단지 링크를 끊어주거나 붙여주면 되기에 기본 연산 O(1)의 시간이 걸린다.(맨 앞과 뒤에 삽입/삭제 인경우)
하지만 원소 접근은 인덱스로 접근이 불가능하기에(Random Access x) 처음 노드부터 차례대로 접근해야 함으로, O(N)시간이 걸린다.(Sequential Access)
```
![](https://velog.velcdn.com/images/choidongkuen/post/273b7567-410a-42c7-a3b0-0ca7248fb0a6/image.png)

```

연결리스트를 이해하기 위해선 용어 정리가 선행되어야 한다. 이는 컴퓨터 공학에서 기본적인 수준의 용어이며 중요하니 위에 이미지를 참고히여 차근차근 공부해보자.

- 용어 정리 🥸

노드(Node) : 정보를 담는 창구라고 생각하면 되며, 노드에는 데이터와 다음 노드에 대한 주소 정보가 담겨 있다.
    #배열과 달리 리스트류의 자료구조는 물리적 메모리에 연속적으로 저장되어 있지 않으며, 다음 데이터에 접근하기 위해선 주소 정보가 필요하다! (중요)

링크(Link) : 노드와 노드를 이어주는 연결고리이다. 방향에는 단방향과 양방향이 있다.

```

```
- 단방향 연결 리스트(SingleLinkedList)

단일 연결 리스트에서 단일이란 연결 방향이 단방향이라는 의미이다. 즉 밑에 이미지 처럼 각 노드가 다음 노드로 이동하는 방향은 정해져있으며
그 방향으로만 갈 수 있다. 
```
![](https://velog.velcdn.com/images/choidongkuen/post/16549df3-9b8b-4e9a-8e50-ac547d3ac43f/image.png)

> 딘일 연결 리스트의 삽입

```

- tail뒤에 삽입하는 경우
tail은 next가 비어있기 때문에, 새로운 노드가 들어오게 된다면 next가 가리키는 노드를 해당 노드로 지정해주면 연결 처리는 큰 문제 없이 될 것이다. 
그러나, 새로운 노드는 현재 tail보다 뒤쪽에 위치할 것이기 때문에, 추가적으로 tail이 가리키는 노드도 변경해줘야 한다.

- 수도 코드 🔥

  function SLL.insert_end(num)
  set new_node = node(num)       # Step 1. 노드 만들기
  SLL.tail.next = new_node       # Step 2. 이어 붙이기
  SLL.tail = new_node            # Step 3. Tail 변경하기

- head뒤에 삽입하는 경우
head앞에 삽입하는 경우도 위에 경우를 이해했다면, 어렵지 않다.

- 수도 코드 🔥
  function SLL.insert_front(num)
  set new_node = node(num)       # Step 1. 노드 만들기
  new_node.next = SLL.head       # Step 2. 이어 붙이기
  SLL.head = new_node            # Step 3. Head 변경하기
  
각각의 구현 과정을 이미지로 첨부하니, 꼭 이해하고 넘어가자
```
> SLL.insert_end(num) 

![](https://velog.velcdn.com/images/choidongkuen/post/5c1263db-456e-4d29-8387-b04c33ee98a8/image.png)

> SLL.insert_front(num)

![](https://velog.velcdn.com/images/choidongkuen/post/489a6fb3-b2a6-444c-9958-f72260e82f62/image.png)


```
- 양방향 연결 리스트(DoublyLinkedList)
    
    앞에서 살펴본 단방향 연결 리스트의 가장 결정적인 단점은 방향이 한방향만 가능하므로, 이전 노드에 접근하기 위해서는 다시 head부터
    차례로 탐색해서 접근해야 한다. 이를 개선하기 위해 방향이 두개인 양방향 연결 리스트를 살펴보자.
    

```




```
 - 연결 리스트 연산 시간 복잡도 정리 🕐(중요)
    
    # 참고로, 연결리스트가 삽입/삭제에 무조건 배열보다 성능이 좋은 겻은 아니다. 확실한 것은 경우에 따라 다르고 상황에 따라 다르다!!!!
    # 데이터를 삽입/삭제 하는 행위 자체의 시간 복잡도는 O(1)이 맞으나, 만약 추가하려는 위치가 맨 처음(head)가 아니라면, 자연스럽게 해당 노드까지 이동하기 위해
    탐색과정이 수반됨으로, O(N)이 된다. (중요)
 
    1. 삽입 
        - 맨 앞에 삽입하는 경우 : O(1)
        - 중간에 삽입하는 경우 : O(N)
        - 맨 뒤에 삽입하는 경우 : O(N) (설명 : tail까지 탐색/접근 과정이 필수)
        
    2. 삭제 
        - 맨 앞에서 삭제하는 경우 : O(1)
        - 중간에서 삭제하는 경우 : O(N)
        - 맨 뒤에서 삭제하는 경우 : O(N) (설명 : tail까지 탐색/접근 과정이 필수)
        
    3. 탐색
        - O(N)
    
    4. 접근
        - O(N)
    
    # 배열과 리스트의 시간복잡도까지 전부 다뤄봤으니 결론을 내보자.
    # 같은 연산에도 경우에 따라 시간복잡도가 달라지기 때문에, 조금은 복잡하게 느껴질지도 모른다. 그러나 간단명료하게 이야기 하고자 한다.
    
    ⭐️ 결론 : 데이터의 접근, 탐색이 중요하면 배열을!! 😎 데이터의 추가, 삭제가 중요하면 연결리스트를!! 🤓 쓰자!!!!
```







